<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>mystical resume</title>
 
<script src="d3.v3.min.js" charset="utf-8"></script>
<script src="topojson.v1.min.js"></script>
 
<style type="text/css">
	.axis path,
	.axis line {
		fill: none;
		stroke: #000;
		shape-rendering: crispEdges;
	}
	.axis text {
		font-family: helvetica;
	}

	.feature {
		fill: none;
		stroke: grey;
		stroke-width: 1px;
  		stroke-linejoin: round;
	}
	.mesh {
		fill: none;
  		stroke: lightgrey;
  		stroke-width: 2px;
  		stroke-linejoin: round;
	}
	h1 {
		font-family: sans-serif;
	}

	#dpi {
		height: 1in;
		left: -100%;
		position: absolute;
		top: -100%;
		width: 1in;
	}

</style>
</head>
<body>

	<div id = "dpi"></div>
	<!--<h1>resume map</h1>-->

	</body>
 
<script type="text/javascript">

//gets current dpi of browser
var paperHeight = 11, paperWidth = 8.5; // dimensions of US letter sized paper


function getDPI() {
	return document.getElementById("dpi").offsetHeight;
}

var yurDPI = getDPI(); // on my laptop, 101 makes the paper size correct to match real paper, but getDPI returns 96



d3.selection.prototype.moveToFront = function() {
  return this.each(function(){
    this.parentNode.appendChild(this);
  });
};

var contiguousCentroid = [-96.583333, 39.0],
	places = [	{"coords" : [-96.2, 41.3],
					"city" : "Elkhorn",
					"state" : "NE",
					"caption" : "Elkhorn High School: 2001-2005",
					"placeName" : "Elkhorn",
					"institution" : "Elkhorn High School",
					"title" : "Student",
					"GPA" : "4.0",
					"honors" : ["National Honors Society"],
					"timeStart" : new Date(2001, 8, 15),
					"timeEnd" : new Date(2005, 5, 25),
					"index" : 0,
					"importance" : 1},
				{"coords" : [-105, 39.7],
					"city" : "Golden",
					"state" : "CO",
					"caption" : "Colorado School of Mines: 2005-2009",
					"placeName" : "Golden",
					"institution" : "Colorado School of Mines",
					"title" : "Student",
					"degree" : "B.S. Chemical Engineering",
					"honors" : ["Tau Beta Pi", "Barry M. Goldwater Scholarship", "Sigma Phi Epsilon President"],
					"timeStart" : new Date(2005, 8, 15),
					"timeEnd" : new Date(2009, 5, 25),
					"index" : 1,
					"importance" : 1},
				{
					"coords": [-119.8, 34.4],
					"city": "Santa Barbara",
					"state": "CA",
					"caption": "UCSB: 2009-2014",
					"placeName": "UCSB",
					"institution": "UCSB",
					"title": "Student",
					"degree": "PhD",
					"honors": ["NSF Fellowship Honorable Mention", "IGERT Fellowship"],
					"skills": [{"Science": [
					["XRD", 4],
					["NMR",5],
					["ESR",3],
					["EXAFS",2],
					["SEM",2],
					["Neutron Scattering",3],
					["Photoluminescence",4],
					["Quantum Yield",4]]},
						{"Manufacturing" : [["High-T ceramics",4]]},
						{"Computing" : [["Python",3],
					["Bash",2],
					["MATLAB",3],
					["Mathematica",2],
					["LaTex",4],
					["Mathematica",2],
					["HTML",2],
					["MS Office",5]]}],
					"timeStart": new Date(2009, 9, 15),
					"timeEnd": new Date(2013, 12, 31),
					"index": 2,
					"importance": 1,
					"presentations": [6, 3], // number of [presentations, international presentations]
					"posters": 6,
					"mentored" : 7, // number of peopled mentored
					"volunteering" : "Volunteered at numerous elementary/middle school science nights, and high-school " +
					"classes.",
					"papers authored" : [16, 3], // number of [papers, first author papers]
				},
				{"coords" : [-121.9, 37.4],
					"city" : "Milpitas",
					"state" : "CA",
					"caption" : "NuvoSun: 2014-2015",
					"placeName" : "NuvoSun",
					"institution" : "NuvoSun",
					"title" : "Device Process Engineer",
					"timeStart" : new Date(2014, 7, 1),
					"timeEnd" : new Date(),
					"index" : 3,
					"importance" : 1}],
	fontSize = 15,
	stateCodes = [],
	honAccumLen = 0;

var padding = {w : 0.35, h : 0.35}, //ems
	lineHeight = 1.2, // ems
	textAdjust = 4; // ems, for moving the text to the right so it doesn't overlap the timescale

var paperMargin = {
	l: 0.1 * yurDPI,
	r: 0.1 * yurDPI,
	t: 0.1 * yurDPI,
	b: 0.1 * yurDPI
};

var width = yurDPI * paperHeight,// 1 pc = 16 px, was 950 before
    height = yurDPI * paperWidth, // was 550 before
		margin = {top:40,bottom:40,left:40,right:40},
	pageMargin = {top: window.innerHeight - height/2, right:window.innerWidth - width/2, bottom:window.innerWidth - width/2, left:window.innerWidth - width/2};

var innerWidth = width - paperMargin.l - paperMargin.r,
		innerHeight = height - paperMargin.t - paperMargin.b;

var x = d3.time.scale()
		.domain([d3.time.year.offset(places[0].timeStart, 0), d3.time.year.offset(places[places.length-1].timeEnd, 0)])
		.rangeRound([0, height - margin.top - margin.bottom]);

var xAxis = d3.svg.axis()
		.scale(x)
		.orient('left')
		.ticks(d3.time.years, 3)
		.tickFormat(d3.time.format('%Y'))
		.tickPadding(8);

var y = d3.scale.linear()
		.domain([0, d3.max(places, function(d) { return (d.index + 1); })])
		.range([innerWidth/10 - margin.left - margin.right, 0]);

var yAxis = d3.svg.axis()
		.scale(y)
		.orient('top')
		.tickPadding(8);

// set projection
var projection = d3.geo.mercator();

// create path variable
var path = d3.geo.path()
    .projection(projection);


d3.json("us.json", function(error, topo) {
	if (error) throw error;

	states = topojson.feature(topo, topo.objects.states).features;

	projection
			.scale(1)// scale to fit whatever size screen it is, original for 950 width was .scale(850)
			.translate([0,0]);

	//var thestates = topojson.feature(us, us.objects.states),
	//		state = thestates.features.filter(function(d) { return d.id !== 15 && d.id !== 2; })[0];

	// create svg variable
	var svgOuter = d3.select("body").append("svg")
			.attr("id", "svgOuter")
			.attr("width", width)
			.attr("height", height);


	// create border around svg
	var borderPath = svgOuter.append("rect")
			.attr("class", "border")
			.attr("x", 0)
			.attr("y", 0)
			.attr("height", height)
			.attr("width", width)
			.style("stroke", "black")
			.style("fill", "none")
			.style("stroke-width", "5");

	var svg = d3.select("#svgOuter").append("svg")
			.attr("width", innerWidth)
			.attr("height", innerHeight)
			.attr("x", paperMargin.l)
			.attr("y", paperMargin.t);

	// load dict of state ids, names, and abbreviations (id, code, name)
	d3.tsv("us-state-names.tsv", function(error, tsv) {
		if (error) throw error;
		// extract just the names and Ids
		var stateIds = [];


		places.forEach(function(d) {
			stateCodes.push(d.state);
		});

		tsv.forEach(function(d) {

			if (stateCodes.indexOf(String(d.code)) > -1) {
				console.log(String(d.code));
				stateIds.push(d.id);
			}
		});

		// this will select the continental US
		/*tsv.forEach(function (d) {
			if (d.id <= 56 && d.id != 2 && d.id != 15) {
				stateIds.push(d.id);
			}

		});*/

	selectedStates = d3.set(stateIds);

	//selection = {type: "FeatureCollection", features: states.filter(function(d) { return stateIds.has(d.id); })};

	mapBorder = topojson.merge(topo, topo.objects.states.geometries.filter(function(d) { return selectedStates.has(d.id); }));

	var b = path.bounds(mapBorder),
			s = .95 / Math.max((b[1][0] - b[0][0]) / innerWidth, (b[1][1] - b[0][1]) / innerHeight),
			t = [(innerWidth - s * (b[1][0] + b[0][0])) / 2, (innerHeight - s * (b[1][1] + b[0][1])) / 2];

	console.log(s);
	console.log(t);

	projection
			.scale(s)
			.translate(t);




	// add states from topojson
	svg.selectAll("path")
			.data(states).enter()
			.append("path")
			.attr("class", "feature")
			.style("fill", "steelblue")
			.attr("d", path);

	// put border around states
	svg.append("path")
			.datum(topojson.mesh(topo, topo.objects.states, function (a, b) {
				return a !== b;
			}))
			.attr("class", "mesh")
			.attr("d", path);

	// add circles (points) to svg
	svg.selectAll("circle")
			.data(places).enter()
			.append("circle")
			.attr("cx", function (d) {
				return projection(d.coords)[0];
			})
			.attr("cy", function (d) {
				return projection(d.coords)[1];
			})
			.attr("r", "8px")
			.attr("fill", "purple")
			.attr("stroke", "orange");

	// add labels to the points
	svg.selectAll("text")
			.data(places).enter()
			.append("text")
			.attr("id", function (d) {
				return d.placeName
			})
			.attr("x", function() {return (textAdjust + padding.w) + "em";})
			.attr("y", function (d) {
				yPos = d.index * lineHeight * d.importance + padding.h + 3 + "em";
				return yPos;
			})
			.attr("dy", lineHeight + padding.h + "em")
			.text(function (d) {
				if (d.honors == undefined) {honorsStr = "";} else {
					honorsStr = " -- honors:";
					for (var i = 0; i< d.honors.length; i++) {
						honorsStr = honorsStr + " " + d.honors[i] + ","
					}
					honorsStr = honorsStr.slice(0,honorsStr.length-1);
				}
				return d.title + " @ " + d.institution + honorsStr;
			})
			.attr("font-family", "sans-serif")
			.attr("font-size", function (d) {
				return fontSize * d.importance + "px";
			})
			.attr("fill", "#fff")
			.call(wrap, innerWidth/2 - textAdjust - padding.w);


	var svgChart = d3.select('svg').append('svg')
			.attr('class', 'chart')
			.attr('width', innerWidth)
			.attr('height', innerHeight)
			.append('g')
			.attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')');


	svgChart.selectAll('.chart')
			.data(places)
			.enter().append('rect')
			.attr('class', 'bar')
			.attr('y', function(d) { return x(d.timeStart); })//confusing now because y is actually x axis...flipped graph on its side
			.attr('x', 0)
			.attr('height', function(d) { return x(d.timeEnd) - x(d.timeStart); })
			.attr('width', function(d) { return innerWidth/10 - margin.left - margin.right - y(d.index + 1)});


	svgChart.append('g')
			.attr('class', 'x axis')
			.attr('transform', 'translate(0, ' + (innerWidth/10 - margin.left - margin.right) + ')')
			.call(xAxis).selectAll("text")
			.attr("y", "1em")
			.attr("x", "-1em")
			.attr("dy", ".35em")
			.attr("transform", "rotate(90)")
			.style("text-anchor", "start");

	/*svgChart.append('g')
			.attr('class', 'y axis')
			.attr('transform', 'translate(' + margin.left + ',0)')
			.call(yAxis);*/

	for (var i = 0, l = places.length; i < l; i++) {
		var bbox = d3.select("#" + places[i].placeName).node().getBBox();
		console.log(bbox);
		var bboxPad = 2;
		svg.append("rect")
				.attr("x", bbox.x  - padding.w * fontSize)
				.attr("y", bbox.y  - padding.h * fontSize)
				.attr("width", innerWidth / 2  + (padding.w * 2) *fontSize)
				.attr("height", bbox.height  + (padding.h * 2) * fontSize)
				.style("fill", "000")
				.style("opacity", "0.5");


		d3.select("#" + places[i].placeName)
				.moveToFront();
	}
	});


});

var lastY,
	textCount = 0;

function wrap(text, width) {
	text.each(function() {
		var text = d3.select(this);
		console.log(this);
		if (textCount>0) {
			console.log("changing y from " + text.attr("y") + " to " + (parseFloat(lastY.slice(0,lastY.length - 2)) + 1.6 + padding.w + "em"));
			d3.select(this).attr("y", parseFloat(lastY.slice(0,lastY.length - 2)) + 1.6 + padding.h + 3 + "em");
		}
		var words = text.text().split(/\s+/).reverse(),
				word,
				line = [],
				lineNumber = 0,
				y = text.attr("y"),
				dy = parseFloat(text.attr("dy")),
				tspan = text.text(null).append("tspan").attr("x", textAdjust + padding.w + "em").attr("y", y).attr("dy", dy + "em");
		lastY = y;
		while (word = words.pop()) {
			line.push(word);
			tspan.text(line.join(" "));
			if (tspan.node().getComputedTextLength() > width) {
				line.pop();
				tspan.text(line.join(" "));
				line = [word];
				tspan = text.append("tspan").attr("x", textAdjust + padding.w + "em").attr("y",++lineNumber * lineHeight + padding.h + 3 + "em").attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
				lastY = ++lineNumber * lineHeight + padding.h + "em";
				console.log(lastY);
			}
		}
	textCount+=1;
	});
}

</script>
    
</body>
</html>